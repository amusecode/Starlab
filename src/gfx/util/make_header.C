
#include "stdinc.h"

// Description of header for files containing SUN raster images:
// (Nothing special about this format -- it just happens to be simple.)

struct rasterfile {
	int	ras_magic;		// magic number
	int	ras_width;		// width (pixels) of image
	int	ras_height;		// height (pixels) of image
	int	ras_depth;		// depth (1, 8, or 24 bits) of pixel
	int	ras_length;		// length (bytes) of image
	int	ras_type;		// type of file; see RT_* below
	int	ras_maptype;		// type of colormap; see RMT_* below
	int	ras_maplength;		// length (bytes) of following map

	// color map follows for ras_maplength bytes, followed by the image
};

// Note: colormap and image are in bytes, so no compatibility problems
// between machines.  However, the byte ordering in the header file is
// important, and has to be right...  Ordering must be such that the
// four bytes of the magic number RAS_MAGIC are stored in the order:
//
//	a6 59 95 6a
//
// On a Sun system, bytes 0, 1, 2, and 3, as defined in check_bytes and
// write_word below, are a6, 59, 95, and 6a, respectively.  On an Intel
// box, they are 95, 6a, a6, and 59, and so must be reordered.
//
// Maybe standard routines exist to figure this out.  My functions below
// at least work...

#define	RAS_MAGIC	0x59a66a95

static int byte_order = 0;	// 0 == Sun, 1 = non-Sun ordering

void check_byte()
{
    int i = RAS_MAGIC;
    unsigned char *c;

    c = (unsigned char*) &i;

    if (*c == 0x59 && *(c+1) == 0xa6)
	byte_order = 0;
    else
	byte_order = 1;
}

void write_word(unsigned char * x, int n, FILE* out_file)
{
    int i1, i2, inc;

    if (byte_order == 0) {
	i1 = 0;
	i2 = n;
	inc = 1;
    } else {
	i1 = n-1;
	i2 = -1;
	inc = -1;
    }
    for (int i = i1; i != i2; i += inc) {
	fwrite(x+i, sizeof(*x), 1, out_file);
	// fprintf(stderr, "wrote %d %x %c\n", i, *(x+i), *(x+i));
    }
}

#define RT_OLD		0	// Raw pixrect image in 68000 byte order
#define RT_STANDARD	1	// Raw pixrect image in 68000 byte order
#define RT_BYTE_ENCODED	2	// Run-length compression of bytes
#define RT_FORMAT_RGB	3	// XRGB or RGB instead of XBGR or BGR
#define RT_FORMAT_TIFF	4	// tiff <-> standard rasterfile
#define RT_FORMAT_IFF	5	// iff (TAAC format) <-> standard rasterfile
#define RT_EXPERIMENTAL 0xffff	// Reserved for testing

#define RMT_RAW		2

#define RMT_NONE	0	// ras_maplength is expected to be 0
#define RMT_EQUAL_RGB	1	// red[ras_maplength/3],green[],blue[]

// NOTES:
// 	Each line of the image is rounded out to a multiple of 16 bits.
//   This corresponds to the rounding convention used by the memory pixrect
//   package (/usr/include/pixrect/memvar.h) of the SunWindows system.
//	The ras_encoding field (always set to 0 by Sun's supported software)
//   was renamed to ras_length in release 2.0.  As a result, rasterfiles
//   of type 0 generated by the old software claim to have 0 length; for
//   compatibility, code reading rasterfiles must be prepared to compute the
//   true length from the width, height, and depth fields.

void make_standard_colormap(unsigned char* red,
			    unsigned char* green,
			    unsigned char* blue)
{
    // Make a simple standard colormap.

    int i;

    for (i = 0; i < 32; i++) {
        red[i] = 0;
        green[i] = 0;
        blue[i] = 8*i;
    }
    for (i = 32; i < 96; i++) {
        red[i] = 0;
        green[i] = 4*(i-32);
        blue[i] = 255;
    }
    for (i = 96; i < 160; i++) {
        red[i] = 4*(i-96);
        green[i] = 255;
        blue[i] = 255 - red[i];
    }
    for (i = 160; i < 224; i++) {
        red[i] = 255;
        green[i] = 255 - 4*(i-160);
        blue[i] = 0;
    }
    for (i = 224; i < 256; i++) {
        red[i] = 255;
        blue[i] = green[i] = 8*(i-224);
    }
}

inline void swap(unsigned char *a, unsigned char *b)
{
    unsigned char tmp = *a;
    *a = *b;
    *b = tmp;
}

void make_alternate_colormap(unsigned char* red,
			     unsigned char* green,
			     unsigned char* blue)
{
    // Make a "reverse standard colormap" (red --> blue).

    int i;

    for (i = 0; i < 48; i++) {				// violet to blue
	red[i] = 5*(48-i)-1;				// 235 117 255
	green[i] = red[i]/2;				//   5   2 255
	blue[i] = 255;
    }
    for (i = 48; i < 86; i++) {				// blue to blue-green
        red[i] = 0;					//   0   0 255
        green[i] = (unsigned char)(6.84*(i-48));	//   0 251 137
        blue[i] = 255 - (unsigned char)(2.5*(i-48));
    }
    for (i = 86; i < 100; i++) {			// blue-green to green
        red[i] = 0;					//   0 251 180
        green[i] = 255 - (100-i)/3;			//   0 255   5
        blue[i] = 135 - 10*(i-86);
    }
    for (i = 100; i < 130; i++) {			// green to yellow
        red[i] = (unsigned char)(8.5*(i-100));		//   0 255   0
        green[i] = 255;					// 24 6255   0
        blue[i] = 0;
    }
    for (i = 130; i < 215; i++) {			// yellow to red
        red[i] = 255;					// 255 255   0
        green[i] = 255 - 3*(i-130);			// 255   3   0
        blue[i] = 0;
    }
    for (i = 215; i < 256; i++) {			// red to dark red
        red[i] = 255 - 2*(i-215);			// 255 255   0
        green[i] = 0;					// 255 175   0
        blue[i] = 0;
    }

    for (i = 0; i < 128; i++) {
	swap(red+i, red+255-i);
	swap(green+i, green+255-i);
	swap(blue+i, blue+255-i);
    }
}

void make_greymap(unsigned char* red,
		  unsigned char* green,
		  unsigned char* blue)
{
    // Make a simple greyscale colormap.

    for (int i = 0; i < 256; i++)
        red[i] = green[i] = blue[i] = i;
}

void make_header(int m, int n, FILE* out_file,
		 unsigned char *red,
		 unsigned char *green,
		 unsigned char *blue)
{
    struct rasterfile r;

    r.ras_magic = RAS_MAGIC;
    r.ras_width = m;
    r.ras_height = n;
    r.ras_depth = 8;
    r.ras_length = m*n;
    r.ras_type = RT_STANDARD;
    r.ras_maptype = RMT_EQUAL_RGB;
    r.ras_maplength = 768;

    // fwrite(&r, sizeof(r), 1, out_file);

    // Horrible kludge to get the byte ordering right in the header...

    check_byte();

    write_word((unsigned char*)&r.ras_magic, sizeof(r.ras_magic), out_file);
    write_word((unsigned char*)&r.ras_width, sizeof(r.ras_width), out_file);
    write_word((unsigned char*)&r.ras_height, sizeof(r.ras_height), out_file);
    write_word((unsigned char*)&r.ras_depth, sizeof(r.ras_depth), out_file);
    write_word((unsigned char*)&r.ras_length, sizeof(r.ras_length), out_file);
    write_word((unsigned char*)&r.ras_type, sizeof(r.ras_type), out_file);
    write_word((unsigned char*)&r.ras_maptype, sizeof(r.ras_maptype), out_file);
    write_word((unsigned char*)&r.ras_maplength, sizeof(r.ras_maplength),
	       out_file);

    // Remaining elements are all bytes, so no special treatment needed.

    fwrite(red, 1, 256, out_file);
    fwrite(green, 1, 256, out_file);
    fwrite(blue, 1, 256, out_file);
}

void make_header(int m, int n, FILE* out_file,
		 char* colormap_file)		// (make our own if NULL)
{
    // Construct a SUN rasterfile header.

    unsigned char red[256], green[256], blue[256];

    FILE* mapfile;

    // Attempt to read a color map.

    if (colormap_file) {
	if ((mapfile = fopen(colormap_file, "r")) == NULL) {
	    fprintf(stderr, "Can't open color map file %s: using default\n",
		    colormap_file);
	    colormap_file = NULL;
	} else {
	    if (fread(red, 1, 256, mapfile) != 256) {
		fprintf(stderr, "Error reading color map: using default\n");
		colormap_file = NULL;
	    } else {
		if (fread(green, 1, 256, mapfile) != 256) {
		    fprintf(stderr, "Error reading color map: using default\n");
		    colormap_file = NULL;
		} else {
		    if (fread(blue, 1, 256, mapfile) != 256) {
			fprintf(stderr,
				"Error reading color map: using default\n");
			colormap_file = NULL;
		    }
		}
	    }
	}
    }

    // Default colormap is now greyscale.

    if (!colormap_file)
	// make_standard_colormap(red, green, blue);
        // make_greymap(red, green, blue);
	make_alternate_colormap(red, green, blue);

    make_header(m, n, out_file, red, green, blue);
}


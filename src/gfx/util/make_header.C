
#include "stdinc.h"

// Description of header for files containing SUN raster images:
// (Nothing special about this format -- it just happens to be simple.)

struct rasterfile {
	int	ras_magic;		// magic number
	int	ras_width;		// width (pixels) of image
	int	ras_height;		// height (pixels) of image
	int	ras_depth;		// depth (1, 8, or 24 bits) of pixel
	int	ras_length;		// length (bytes) of image
	int	ras_type;		// type of file; see RT_* below
	int	ras_maptype;		// type of colormap; see RMT_* below
	int	ras_maplength;		// length (bytes) of following map

	// color map follows for ras_maplength bytes, followed by image
};

// Note: colormap and image are in bytes, so no compatibility problems
// between machines.  However, the byte ordering in the header file is
// important, and has to be right...  Ordering must be such that the
// four bytes of the magic number RAS_MAGIC are stored in the order:
//
//	a6 59 95 6a
//
// On a Sun system, bytes 0, 1, 2, and 3, as defined in check_bytes and
// write_word below, are a6, 59, 95, and 6a, respectively.  On an Intel
// box, they are 95, 6a, a6, and 59, and so must be reordered.
//
// Maybe standard routines exist to figure this out.  My functions below
// at least work...

#define	RAS_MAGIC	0x59a66a95

static int byte_order = 0;	// 0 == Sun, 1 = non-Sun ordering

void check_byte()
{
    int i = RAS_MAGIC;
    unsigned char *c;

    c = (unsigned char*) &i;

    if (*c == 0x59 && *(c+1) == 0xa6)
	byte_order = 0;
    else
	byte_order = 1;
}

void write_word(unsigned char * x, int n, FILE* out_file)
{
    int i1, i2, inc;

    if (byte_order == 0) {
	i1 = 0;
	i2 = n;
	inc = 1;
    } else {
	i1 = n-1;
	i2 = -1;
	inc = -1;
    }
    for (int i = i1; i != i2; i += inc) {
	fwrite(x+i, sizeof(*x), 1, out_file);
	// fprintf(stderr, "wrote %d %x %c\n", i, *(x+i), *(x+i));
    }
}

#define RT_OLD		0	// Raw pixrect image in 68000 byte order
#define RT_STANDARD	1	// Raw pixrect image in 68000 byte order
#define RT_BYTE_ENCODED	2	// Run-length compression of bytes
#define RT_FORMAT_RGB	3	// XRGB or RGB instead of XBGR or BGR
#define RT_FORMAT_TIFF	4	// tiff <-> standard rasterfile
#define RT_FORMAT_IFF	5	// iff (TAAC format) <-> standard rasterfile
#define RT_EXPERIMENTAL 0xffff	// Reserved for testing

#define RMT_RAW		2

#define RMT_NONE	0	// ras_maplength is expected to be 0
#define RMT_EQUAL_RGB	1	// red[ras_maplength/3],green[],blue[]

// NOTES:
// 	Each line of the image is rounded out to a multiple of 16 bits.
//   This corresponds to the rounding convention used by the memory pixrect
//   package (/usr/include/pixrect/memvar.h) of the SunWindows system.
//	The ras_encoding field (always set to 0 by Sun's supported software)
//   was renamed to ras_length in release 2.0.  As a result, rasterfiles
//   of type 0 generated by the old software claim to have 0 length; for
//   compatibility, code reading rasterfiles must be prepared to compute the
//   true length from the width, height, and depth fields.

static void make_colormap(unsigned char* red,
		   unsigned char* green,
		   unsigned char* blue)
{
    // Make a simple standard colormap.

    int i;

    for (i = 0; i < 32; i++) {
        red[i] = 0;
        green[i] = 0;
        blue[i] = 8*i;
    }
    for (i = 32; i < 96; i++) {
        red[i] = 0;
        green[i] = 4*(i-32);
        blue[i] = 255;
    }
    for (i = 96; i < 160; i++) {
        red[i] = 4*(i-96);
        green[i] = 255;
        blue[i] = 255 - red[i];
    }
    for (i = 160; i < 224; i++) {
        red[i] = 255;
        green[i] = 255 - 4*(i-160);
        blue[i] = 0;
    }
    for (i = 224; i < 256; i++) {
        red[i] = 255;
        blue[i] = green[i] = 8*(i-224);
    }
}

void make_header(int m, int n, FILE* out_file, char* colormap_file)
{
    // Construct a SUN rasterfile header.

    int i;
    unsigned char red[256], green[256], blue[256];

    struct rasterfile r;
    FILE* mapfile;

    // Attempt to read a color map.

    if (colormap_file) {
	if ((mapfile = fopen(colormap_file, "r")) == NULL) {
	    fprintf(stderr, "Can't open color map file %s: using default\n",
		    colormap_file);
	    colormap_file = NULL;
	} else {
	    if (fread(red, 1, 256, mapfile) != 256) {
		fprintf(stderr, "Error reading color map: using default\n");
		colormap_file = NULL;
	    } else {
		if (fread(green, 1, 256, mapfile) != 256) {
		    fprintf(stderr, "Error reading color map: using default\n");
		    colormap_file = NULL;
		} else {
		    if (fread(blue, 1, 256, mapfile) != 256) {
			fprintf(stderr,
				"Error reading color map: using default\n");
			colormap_file = NULL;
		    }
		}
	    }
	}
    }

    r.ras_magic = RAS_MAGIC;
    r.ras_width = m;
    r.ras_height = n;
    r.ras_depth = 8;
    r.ras_length = m*n;
    r.ras_type = RT_STANDARD;
    r.ras_maptype = RMT_EQUAL_RGB;
    r.ras_maplength = 768;

    // fwrite(&r, sizeof(r), 1, out_file);

    // Horrible kludge to get the byte ordering right in the header...

    check_byte();

    write_word((unsigned char*)&r.ras_magic, sizeof(r.ras_magic), out_file);
    write_word((unsigned char*)&r.ras_width, sizeof(r.ras_width), out_file);
    write_word((unsigned char*)&r.ras_height, sizeof(r.ras_height), out_file);
    write_word((unsigned char*)&r.ras_depth, sizeof(r.ras_depth), out_file);
    write_word((unsigned char*)&r.ras_length, sizeof(r.ras_length), out_file);
    write_word((unsigned char*)&r.ras_type, sizeof(r.ras_type), out_file);
    write_word((unsigned char*)&r.ras_maptype, sizeof(r.ras_maptype), out_file);
    write_word((unsigned char*)&r.ras_maplength, sizeof(r.ras_maplength),
	       out_file);

    // Remaining elements are all bytes, so no special treatment needed.

    if (!colormap_file) make_colormap(red, green, blue);

    fwrite(red, 1, 256, out_file);
    fwrite(green, 1, 256, out_file);
    fwrite(blue, 1, 256, out_file);
}

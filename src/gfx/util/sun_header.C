
#include "stdinc.h"
#include "image_fmt.h"

// Description of header for files containing SUN raster images:
// (nothing special about this format -- it just happens to be simple.)

struct rasterfile {
	int	ras_magic;		// magic number
	int	ras_width;		// width (pixels) of image
	int	ras_height;		// height (pixels) of image
	int	ras_depth;		// depth (1, 8, or 24 bits) of pixel
	int	ras_length;		// length (bytes) of image
	int	ras_type;		// type of file; see RT_* below
	int	ras_maptype;		// type of colormap; see RMT_* below
	int	ras_maplength;		// length (bytes) of following map

	// color map follows for ras_maplength bytes, followed by the image
};

// Note: colormap and image are in bytes, so no compatibility problems
// between machines.  However, the byte ordering in the header file is
// important, and has to be right...  Ordering must be such that the
// four bytes of the magic number RAS_MAGIC are stored in the order:
//
//	a6 59 95 6a
//
// On a Sun system, bytes 0, 1, 2, and 3, as defined in check_bytes and
// write_word below, are a6, 59, 95, and 6a, respectively.  On an Intel
// box, they are 95, 6a, a6, and 59, and so must be reordered.
//
// Maybe standard routines exist to figure this out.  My functions below
// at least work...

#define	RAS_MAGIC	0x59a66a95

static int byte_order = 0;	// 0 == Sun, 1 = non-Sun ordering

local void check_byte()
{
    int i = RAS_MAGIC;
    unsigned char *c;

    c = (unsigned char*) &i;

    if (*c == 0x59 && *(c+1) == 0xa6)
	byte_order = 0;
    else
	byte_order = 1;
}

local void write_word(unsigned char * x, int n, FILE* out_file)
{
    int i1, i2, inc;

    if (byte_order == 0) {
	i1 = 0;
	i2 = n;
	inc = 1;
    } else {
	i1 = n-1;
	i2 = -1;
	inc = -1;
    }
    for (int i = i1; i != i2; i += inc) {
	fwrite(x+i, sizeof(*x), 1, out_file);
	// fprintf(stderr, "wrote %d %x %c\n", i, *(x+i), *(x+i));
    }
}

#define RT_OLD		0	// Raw pixrect image in 68000 byte order
#define RT_STANDARD	1	// Raw pixrect image in 68000 byte order
#define RT_BYTE_ENCODED	2	// Run-length compression of bytes
#define RT_FORMAT_RGB	3	// XRGB or RGB instead of XBGR or BGR
#define RT_FORMAT_TIFF	4	// tiff <-> standard rasterfile
#define RT_FORMAT_IFF	5	// iff (TAAC format) <-> standard rasterfile
#define RT_EXPERIMENTAL 0xffff	// Reserved for testing

#define RMT_RAW		2

#define RMT_NONE	0	// ras_maplength is expected to be 0
#define RMT_EQUAL_RGB	1	// red[ras_maplength/3],green[],blue[]

// NOTES:
// 	Each line of the image is rounded out to a multiple of 16 bits.
//   This corresponds to the rounding convention used by the memory pixrect
//   package (/usr/include/pixrect/memvar.h) of the SunWindows system.
//	The ras_encoding field (always set to 0 by Sun's supported software)
//   was renamed to ras_length in release 2.0.  As a result, rasterfiles
//   of type 0 generated by the old software claim to have 0 length; for
//   compatibility, code reading rasterfiles must be prepared to compute the
//   true length from the width, height, and depth fields.

void write_sun_header(int m, int n, FILE* out_file,
		      unsigned char *red,
		      unsigned char *green,
		      unsigned char *blue)
{
    // Construct a SUN rasterfile header.

    struct rasterfile r;

    r.ras_magic = RAS_MAGIC;
    r.ras_width = m;
    r.ras_height = n;
    r.ras_depth = 8;
    r.ras_length = m*n;
    r.ras_type = RT_STANDARD;
    r.ras_maptype = RMT_EQUAL_RGB;
    r.ras_maplength = 768;

    // fwrite(&r, sizeof(r), 1, out_file);

    // Horrible kludge to get the byte ordering right in the header...

    check_byte();

    write_word((unsigned char*)&r.ras_magic, sizeof(r.ras_magic), out_file);
    write_word((unsigned char*)&r.ras_width, sizeof(r.ras_width), out_file);
    write_word((unsigned char*)&r.ras_height, sizeof(r.ras_height), out_file);
    write_word((unsigned char*)&r.ras_depth, sizeof(r.ras_depth), out_file);
    write_word((unsigned char*)&r.ras_length, sizeof(r.ras_length), out_file);
    write_word((unsigned char*)&r.ras_type, sizeof(r.ras_type), out_file);
    write_word((unsigned char*)&r.ras_maptype, sizeof(r.ras_maptype), out_file);
    write_word((unsigned char*)&r.ras_maplength, sizeof(r.ras_maplength),
	       out_file);

    // Remaining elements are all bytes, so no special treatment needed.

    fwrite(red, 1, 256, out_file);
    fwrite(green, 1, 256, out_file);
    fwrite(blue, 1, 256, out_file);
}

void write_sun_header(int m, int n, FILE* out_file,
		      char* colormap_file)	    // default = NULL
{
    unsigned char red[256], green[256], blue[256];

    get_colormap(red, green, blue, colormap_file);
    write_sun_header(m, n, out_file, red, green, blue);
}


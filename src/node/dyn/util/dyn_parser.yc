/*
 *  Bison parser specifying Starlab's dyn format grammar.
 *  Copyright (C) 2003  StarCluster team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


%{

  #include <vector>
  #include <stack>
  #include "dyn.h"

  extern char* yytext;
  stack<dyn*> p;
  unsigned long lineno = 1;
  vector<double>* v_ptr;
  //vector<char*> vals;
  struct { char* s; size_t n; } story_line;

  void yyerror(const string err) {
    cerr << err << " on line #" << lineno << " at `" << yytext << "'\n";
    exit(1);
  }

  int yylex(void);

%}

%union {
  double real;
  char* string;
  dyn* dyn_ptr;
  vector<double>* realvec_ptr;
}

%token PARTICLE LOG DYNAMICS HYDRO STAR
%token <string> KEYWORD LOG_STORY STRING
%token <real> NUMBER
%type <dyn_ptr> particle particles
%type <realvec_ptr> real_vec
// this grammar has two shift/reduce conflicts, the empty particle and particles
%expect 2


%%

particle:	{ /* $$ = $1 */ } | '(' PARTICLE {
  p.push(static_cast<dyn*>(new_dyn(new_hydrobase, new_starbase, true)));
}
		  key_val_pairs log dynamics hydro star particles ')' PARTICLE {
  if (p.size() > 1) $$ = p.top(), p.pop(); else return 0;
};

particles:	  { $$ = 0; } | particles particle {
  $2->set_parent(p.top());
  if ($1) $1->set_younger_sister($2); else p.top()->set_oldest_daughter($2);
  $$ = $2;
};

log:		  '(' LOG log_story ')' LOG;

log_story:	| log_story LOG_STORY { p.top()->log_comment($2); free($2); };

dynamics:	  '(' DYNAMICS key_val_pairs ')' DYNAMICS;

hydro:		  '(' HYDRO key_val_pairs ')' HYDRO;

star:		  '(' STAR key_val_pairs ')' STAR;

key_val_pairs:	| key_val_pairs key_val_pair;

key_val_pair:	  KEYWORD '=' real_vec {
  if      (!strcmp($1, "i")) p.top()->set_index(int((*$3)[0]));
  else if (!strcmp($1, "system_time")) p.top()->set_system_time((*$3)[0]);
  else if (!strcmp($1, "m")) p.top()->set_mass((*$3)[0]);
  else if (!strcmp($1, "r")) p.top()->set_pos(vec((*$3)[0],(*$3)[1],(*$3)[2]));
  else if (!strcmp($1, "v")) p.top()->set_vel(vec((*$3)[0],(*$3)[1],(*$3)[2]));
  else if (!strcmp($1, "a")) p.top()->set_acc(vec((*$3)[0],(*$3)[1],(*$3)[2]));
  else {
    /*
    ostringstream line;
    line << $1 << " =";
    for (size_t i = 0; i < $3->size(); line << ' ' << (*$3)[i++]);
    add_story_line(p.top()->get_dyn_story(),
		   const_cast<char*>(line.str().c_str()));
    */
    /*
    char* line;
    switch ($3->size()) {
    case 1: asprintf(&line, "%s = %g", $1, (*$3)[0]); break;
    case 3:
      asprintf(&line, "%s = %g %g %g", $1, (*$3)[0], (*$3)[1], (*$3)[2]); break;
    default:
      asprintf(&line, "%s =", $1);
      for (size_t i = 0; i < $3->size(); ++i) {
	char* l;
	asprintf(&l, " %g", (*$3)[i]);
	line = static_cast<char*>(realloc(line, strlen(line)+strlen(l)+1));
	strcat(line, l);
	free(l);
      }
    }
    */
    /*
    size_t tl = strlen($1)+2+1;
    for (size_t i = 0; i < vals.size(); tl += strlen(vals[i++])+1);
    char line[tl], *li;
    line[0] = '\0';
    li = stpcpy(stpcpy(line, $1), " =");
    for (size_t i = 0; i < vals.size(); free(vals[i++]))
      li = stpcpy(stpcpy(li, " "), vals[i]);
    add_story_line(p.top()->get_dyn_story(), line);
    //free(line);
    */
    char line[strlen($1)+2+story_line.n+1];
    line[0] = '\0';
    strcpy(stpcpy(stpcpy(line, $1), " ="), story_line.s);
    add_story_line(p.top()->get_dyn_story(), line);
  }
  free($1);
  $3->clear();
  //vals.clear();
  *story_line.s = story_line.n = 0;
}
		| KEYWORD '=' STRING {
  /*
  char* line;
  asprintf(&line, "%s = %s", $1, $3);
  */
  char line[strlen($1)+3+strlen($3)+1];
  line[0] = '\0';
  stpcpy(stpcpy(stpcpy(line, $1), " = "), $3);
  add_story_line(p.top()->get_dyn_story(), line);
  free($1), free($3);//, free(line);
};

real_vec:	{ $$ = v_ptr; } | real_vec NUMBER { $1->push_back($2); };


%%


dyn* fget_dyn(FILE* fp) {

  extern FILE* yyin;
  v_ptr = new vector<double>;
  yyin = fp;
  yyparse();
  dyn* const root = p.empty() ? 0 : p.top();
  p.pop();
  delete v_ptr;
  return root;

}

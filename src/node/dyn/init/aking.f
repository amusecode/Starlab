
c       //=======================================================//    _\|/_
c      //  __  _____           ___                    ___       //      /|\
c     //  /      |      ^     |   \  |         ^     |   \     //          _\|/_
c    //   \__    |     / \    |___/  |        / \    |___/    //            /|\
c   //       \   |    /___\   |  \   |       /___\   |   \   // _\|/_
c  //     ___/   |   /     \  |   \  |____  /     \  |___/  //   /|\     
c //                                                       //            _\|/_
c//=======================================================//              /|\

c     Fortran-77 worker function (hidden inside mk_aniso_king.C).

      subroutine aking(mass, xx, yy, zz, vx, vy, vz,
     &                 alpha1_in, alpha3_in, iseed, N_in, W0_in, debug,
     &        	       potential, kinetic, tidal_energy,
     &  	       coord)

c     Program to make an anisotropic King model (cf. Heggie & Ramamani,
c     MNRAS, 272, 317-22, 1995.)
c
c     Written (thrown together) by d.c.heggie@uk.ac.ed
c     This program comes without warranty.
c     
c     Function version created by SLWM.
c
c     Arguments are: arrays for masses, coordinates and velocities,
c                    alpha1 (< 0), alpha3, iseed, N, W0 (1 < W0 < 12),
c     		     debug.
c
c     The Galactic tidal potential per unit mass (with the convention
c         that the potential is negative deep inside a bound system) is
c
c         0.5 * (alpha1*x**2 + alpha3*z**2)
c
c     For a point-mass tidal field, we have
c
c     		alpha1 = -3 Omega^2
c     		alpha3 =    Omega^2
c
c     where Omega^2 is as defined in Binney and Tremaine (and used in
c     kira).
c
c     iseed is a seed for setting the random number generator
c     N is the number of particles required in an N-body model; if n<=1 
c         no particles are generated, but the surface density profile is 
c         computed and printed
c     W0 is the concentration of a King model from which the anisotropic
c         model is generated by perturbation
c     |debug| > 0 prints/saves info about the King model itself
c     debug < 0 prints extra diagnostic messages
c
c     Parameters from original program now set to specific values:
c
c     mtot is the total mass of the system
c     G is G
c     xstart generates the initial value of W by W(0) = W0 - xstart
c
c     **** Take mtot = G = 1, xstart = 0.001. ****
c
c     Units:
c
c     "Internal" code length unit (used in computation of the King model)
c     is the core radius (defined in the usual way).
c
c     "External" units are defined by the fact that G = 1, the model has
c     total mass mtot = 1, and exactly fills its Roche lobe in the Galactic
c     tidal field (i.e. defined by G, mtot, and the alpha parameters).
c
c     The value of alpha1 determines the overall length scale of the output
c     model.  If we plan to rescale externally (e.g. N-body units), then
c     this scale is irrelevant.  ONLY -alpha3/alpha1, WHICH DEFINES THE
c     "SHAPE" OF THE TIDAL POTENTIAL, MATTERS IN THAT CASE.
c
c     Output:
c
c     Unit 0 (stderr) shows
c     		1. the course of the iteration in which the analytic
c		   model is computed (debug < 0),
c		2. the density profiles along the three axes (in
c		   program units) (|debug| > 0), and, 
c		3. the limiting radii along the three axes, in both
c		   program and user units
c     Unit 7 produces surface densities (along the x and z axes,
c         as viewed along the y-axis) if N<=1 (|debug| > 1)
c     Unit 8 produces a list of the analytic solution (|debug| > 1)

      implicit double precision (a-h,o-z)

      double precision mass(N_in), xx(N_in), yy(N_in), zz(N_in),
     &        vx(N_in), vy(N_in), vz(N_in)
      double precision alpha1, alpha3, W0
      integer iseed, N_in, debug
      double precision kinetic, potential, tidal_energy

      parameter(ne=5,m=51,nb=3,nci=ne,ncj=ne-nb+1,nck=m+1,nsi=ne,
     &        nsj=2*ne+1,nyj=ne,nyk=m,nstarm=10000)

c     Note: nstarm was used to set the size of the coord array
c           -- no longer used (dynamically allocated in mk_aniso_king).

      common x(m),h,mm,n,c2,anorm
      common /path/ kmax,kount,dxsav,xp(200),yp(10,200)
      double precision mtot,mstar,j22,ke,kevir
      common /params/ w0,alpha1,alpha3,rho(m),rhodot(m),rlag,yking(2,m),
     &        den,rking
      dimension scalv(ne),indexv(ne),y(ne,m),c(nci,ncj,nck),s(nsi,nsj)
      parameter (nmax=10)

      dimension ystart(nmax),coord(N_in,3)	! <-- new declaration of coord

c     data scalv/4*0.001d0,1.d0/
      data scalv/5*1.d0/
      external derivs,rkqc

c     Function erf could/should be replaced by intrinsic if possible.

      densty(z) = -sqrt(z)*(z+1.5d0)+0.75*sqrt(pi)*exp(z)
     &                    *dch_erf(sqrt(z))

      if (alpha3_in.ne.0.d0 .and. alpha1_in.ge.0.d0) then
          write(0,*) 'aking: alpha1 should be negative'
          stop
      endif
      if (w0_in.lt.0.1d0) then
          write(0,*) 'aking: w0 too small'
          stop
      endif
      if (w0_in.gt.12.d0) then
          write(0,*) 'aking: w0 too large'
          stop
      endif

      pi = 4.d0*atan(1.d0)
      itmax=100
      conv=5.e-6
      h=1.d0/(m-1)

      mtot = 1.0
      G = 1.0

      alpha1 = alpha1_in
      alpha3 = alpha3_in
      N = N_in
      W0 = W0_in

      xstart = 0.001

      itmax = 100
c     rmin = 0.2
c     xstart = 0.2
      slowc = 1.d0
      do i = 1,5
          indexv(i) = i
      enddo
      anorm=1.
      h = (w0-xstart)**2/(m-1)
      den = densty(w0)
      dxsav = 0.01d0*w0
      kmax = 200
      nvar = 2
c     xstart = 0.02
c     xstart = 0.001
      ystart(1) = 2.d0*xstart/3.d0
      ystart(2) = -2.d0/3.d0

c     Compute the King model and perturbations to it.
c
c     In the computation of the King model, y1 = r^2, y2 = d(y1)/dx, 
c     and x is dimensionless depth (w).

      x1 = w0 - xstart
      x2 = 0.d0
      tol = 1.d-6
      h1 = 0.01d0
      hmin = 0.0000000001d0

      call odeint(ystart,nvar,x1,x2,tol,h1,hmin,nok,nbad,derivs,rkqc)

      do k=1,m
          x(k) = w0-xstart-sqrt(h*(k-1))
          if (x(k).ge.0.d0) then
              rho(k) = densty(x(k))/den
              rhodot(k) = rho(k) + x(k)**1.5d0/den
          else
              rho(k) = 0.d0
              rhodot(k) = 0.d0
          endif
          if (x(k).gt.xp(1)) then
              yking(1,k) = (w0-x(k))*yp(1,1)/(w0 - xp(1))
              yking(2,k) = yp(2,1)
          else
              i = 1
115           continue
              if ((x(k)-xp(i))*(x(k)-xp(i+1)).le.0.d0) then
                  yking(1,k) = yp(1,i) + (yp(1,i+1)-yp(1,i))*
     &                    (x(k)-xp(i))/(xp(i+1)-xp(i))
                  yking(2,k) = yp(2,i) + (yp(2,i+1)-yp(2,i))*
     &                    (x(k)-xp(i))/(xp(i+1)-xp(i))
              else
                  i = i+1
                  if (i.le.kount-1) then
                      goto 115
                  else
                      if (debug .lt. 0) then
                          write(0,*) 'aking: failing interpolation',
     &                            ' of King values?', xp(kount), x(k)
                      endif
                      yking(1,k) = yp(1,kount)
                      yking(2,k) = yp(2,kount)
                  endif
              endif
          endif
          y(1,k) = -0.000004*(1-x(k)/w0)
          y(2,k) = 0.000004/w0
          y(3,k) = 0.000001*(1-x(k)/w0)
          y(4,k) = -0.000001/w0
          y(5,k) = log(0.000002d0)
      enddo

      call solvde(itmax,conv,slowc,scalv,indexv,ne,nb,m,y,nyj,nyk,
     &        c,nci,ncj,nck,s,nsi,nsj,debug)

      if (abs(debug) .gt. 1) then
          if (debug .lt. 0)
     $            write(0,*)'aking: writing model to unit 8...'
          do j = 1,m
              write(8,100) x(j),(yking(i,j),i=1,2),(y(i,j),i=1,5)
100           format(0pf10.5,1p7e10.2)
          enddo
      endif

c     Now compute the density profiles

      s0 = 1.5d0*(1.d0+alpha3/alpha1)		! FIRST use of alpha3/alpha1
      s2x = -0.5d0*alpha3/alpha1 + 1.d0
      s2y = s2x - 1.5d0
      s2z = alpha3/alpha1 - 0.5d0
      eps = - exp(y(5,m))
      wyold = -1.d0
      wzold = -1.d0

      if (abs(debug) .gt. 0)
     &    write(0,*) '  radius    density on x',
     &               '      on y           on z           King'

      fmax = 0.d0
      do i = 1,m
          r = sqrt(yking(1,i))
          wx = x(i) + y(1,i)*s0 + y(3,i)*s2x - eps*r**2*
     &            (2.d0/3.d0)*(s0/3.d0 + s2x)
          wy = x(i) + y(1,i)*s0 + y(3,i)*s2y - eps*r**2*
     &            (2.d0/3.d0)*(s0/3.d0 + s2y)
          wz = x(i) + y(1,i)*s0 + y(3,i)*s2z - eps*r**2*
     &            (2.d0/3.d0)*(s0/3.d0 + s2z)
          if (wx.ge.0.d0) then 
              rhox = densty(wx)/den
          else
              rhox = 0.d0
          endif
          if (wy.ge.0.d0) then 
              rhoy = densty(wy)/den
          else
              rhoy = 0.d0
          endif
          if (wz.ge.0.d0) then 
              rhoz = densty(wz)/den
          else
              rhoz = 0.d0
          endif

          if (abs(debug) .gt. 0) write(0,101) r,rhox,rhoy,rhoz,rho(i)
101       format(0pf10.5,1p4d15.5)

          if (fmax.lt.r**2*rhox) fmax = r**2*rhox
          if (wyold.gt.0.d0) ymax = (r*wyold - wy*
     &            sqrt(yking(1,i-1)))/(wyold-wy)
          if (wzold.gt.0.d0) zmax = (r*wzold - wz*
     &            sqrt(yking(1,i-1)))/(wzold-wz)
          wyold = wy
          wzold = wz
      enddo
      r = r + 0.1
10    continue

      wc1 = -2.d0*yking(1,m)**1.5d0/yking(2,m)

c         = 9 M(r) / (4 pi rho0)

      wc2 = -wc1/sqrt(yking(1,m))

c         = -9 M(r) / (4 pi rho0 r)

      w0c1 = wc1*y(2,m)
      w0c2 = y(1,m) - w0c1/sqrt(yking(1,m))
      w2c1 = yking(1,m)**1.5d0*y(3,m)
      wx = wc1/r + wc2
     &        +s0*(w0c1/r + w0c2) + s2x*w2c1/r**3 - eps*r**2*
     &        (2.d0/3.d0)*(s0/3.d0 + s2x)
      wy = wc1/r + wc2
     &        +s0*(w0c1/r + w0c2) + s2y*w2c1/r**3 - eps*r**2*
     &        (2.d0/3.d0)*(s0/3.d0 + s2y)
      wz = wc1/r + wc2
     &        +s0*(w0c1/r + w0c2) + s2z*w2c1/r**3 - eps*r**2*
     &        (2.d0/3.d0)*(s0/3.d0 + s2z)
      if (wx.ge.0.d0) then 
          rhox = densty(wx)/den
      else
          rhox = 0.d0
      endif
      if (wy.ge.0.d0) then 
          rhoy = densty(wy)/den
      else
          rhoy = 0.d0
      endif
      if (wz.ge.0.d0) then 
          rhoz = densty(wz)/den
      else
          rhoz = 0.d0
      endif
      if (wyold.gt.0.d0) ymax = (r*wyold - wy*(r-0.1d0))/
     &        (wyold-wy)
      if (wzold.gt.0.d0) zmax = (r*wzold - wz*(r-0.1d0))/
     &        (wzold-wz)
      wyold = wy
      wzold = wz
      rhok = 0.d0

      if (abs(debug) .gt. 0) write(0,101) r,rhox,rhoy,rhoz,rhok

      if (fmax.lt.r**2*rhox) fmax = r**2*rhox
      r = r + 0.1
      if (r.lt.rlag) goto 10
      fmax = 1.1d0

c     Reminder from Steve to Steve (7/16/98): at this point, lengths
c     are measured in core radii and the density is scaled to the
c     central value.

      write(0,*) 'aking: scaled masses:  King ', wc1,
     &           '   anisotropic ', wc1+s0*w0c1
      write(0,*) 'aking: radii (core radii):',rlag, ymax, zmax
      rking = sqrt(yking(1,m))
      write(0,*) 'aking: King cutoff radius (core radii):',rking
      write(0,'('' aking: scaled densities:  King: '',1pe9.3, '
     &        //'''   aniso: '', e9.3,''    W0 = '',0pf7.3)')
     &        wc1*3/(4*pi*rking**3), 
     &        (wc1 + s0*w0c1)*3/(4*pi*rlag**3), W0

c     Next section computes surface density viewed parallel to y-axis

      if (abs(debug).gt.1) then
          zero = 0.d0
          sigma0 = sigma(zero,zero,y)
          if (debug .lt. 0)
     &            write(0,*) 'Writing surface densities to unit 7...'
          do i = 1,250
              x1 = 10.d0**(0.01d0*(i-1))
              if (x1.le.rlag) then
                  sigmax = sigma(x1,zero,y)/sigma0
                  sigmaz = sigma(zero,x1,y)/sigma0
                  write(7,*) x1, sigmax, sigmaz
              endif
          enddo
      endif

c     Next section computes N-body initial conditions.  Note that alpha1
c     is used to establish scaling.

      idum = iseed

c     Compute core radius in user units:

      rc3 = 2.d0*g*mtot*eps/(alpha1*(wc1 + s0*w0c1))	! FIRST use of alpha1

c     (This eps really is the eps in the paper, although it is
c     obtained here as a solution to a boundary-value problem.)

      rc = rc3**(1.d0/3.d0)
      write(0,*)'aking: core radius (user units) = ', rc

c     Compute 1 / (1-D velocity dispersion) in user units:

      rc2 = rc**2
      j22 = 2.d0*eps/(rc2*alpha1)

      pe = 0.d0
      ke = 0.d0
      sumx = 0.d0
      sumy = 0.d0
      sumz = 0.d0

      do 40 i = 1,n
          if (n.le.1) goto 40
15        continue
          rstar = rlag*ran2(idum)
          costh = 2.d0*ran2(idum)-1.d0
          phi = 2.d0*pi*ran2(idum)
          sinth = sqrt(1.d0-costh**2)
          xstar = rstar*sinth*cos(phi)
          ystar = rstar*sinth*sin(phi)
          zstar = rstar*costh
          r2s2 = (alpha3/alpha1-0.5d0)*(zstar**2-0.5d0*(xstar**2+
     &            ystar**2))+ 0.75d0*(xstar**2-ystar**2)
          r2 = xstar**2 + ystar**2 + zstar**2
          s2 = r2s2/r2
          r = sqrt(r2)
          if (r.lt.rking) then
              if (r.lt.sqrt(yking(1,1))) then
                  w1 = x(1) + y(1,1)*s0 + y(3,1)*s2 - eps*r**2*
     &                    (2.d0/3.d0)*(s0/3.d0 + s2)
                  w = w0 - (r2/yking(1,1))*(w0 - w1)
              else
                  j = 1
20                continue
                  j = j + 1
                  if (r.gt.sqrt(yking(1,j))) goto 20
                  wj1 = x(j-1) + y(1,j-1)*s0 + y(3,j-1)*s2 - eps*r**2*
     &                    (2.d0/3.d0)*(s0/3.d0 + s2)
                  wj = x(j) + y(1,j)*s0 + y(3,j)*s2 - eps*r**2*
     &                    (2.d0/3.d0)*(s0/3.d0 + s2)
                  w = wj1 + (r2-yking(1,j-1))*(wj-wj1)/
     &                    (yking(1,j)-yking(1,j-1))
              endif
          else
              w = wc1/r + wc2
     &                +s0*(w0c1/r + w0c2) + s2*w2c1/r**3 - eps*r**2*
     &                (2.d0/3.d0)*(s0/3.d0 + s2)
          endif
          if (w.gt.0.d0) then
              rhost = densty(w)/den
          else
              rhost = 0
          endif
          if (rstar**2*rhost.lt.fmax*ran2(idum)) go to 15

c         Now choose speed

          vmax = sqrt(2.d0*w)
30        continue
          speed = vmax*ran2(idum)
          fstar = speed**2*(exp(-0.5d0*speed**2)-exp(-w))
          if (fstar.lt.2.d0*ran2(idum)/exp(1.d0)) go to 30
          costh = 2.d0*ran2(idum)-1.d0
          phi = 2.d0*pi*ran2(idum)
          sinth = sqrt(1.d0-costh**2)

c         Convert positions and velocities from code units to user units.

          speed = speed/sqrt(j22)

          xstar = xstar*rc
          ystar = ystar*rc
          zstar = zstar*rc
          ustar = speed*sinth*cos(phi)
          vstar = speed*sinth*sin(phi)
          wstar = speed*costh
          mstar = mtot/n

          coord(i,1) = xstar
          coord(i,2) = ystar
          coord(i,3) = zstar

c         Ultimately, might be better to compute energies, etc. in
c         mk_aniso_king, but keep code as is for now.  Avoid significant
c         cost of computing energy twice by passing energies back to
c         mk_aniso_king via the argument list.

          if (i.gt.1) then
              do j = 1,i-1
                  r2 = (coord(j,1)-xstar)**2 + (coord(j,2)-ystar)**2 + 
     &                    (coord(j,3)-zstar)**2
                  pe = pe - 1.d0/sqrt(r2)
              enddo
          endif
          ke = ke + mstar*speed**2
          sumx = sumx + mstar*xstar**2
          sumy = sumy + mstar*ystar**2
          sumz = sumz + mstar*zstar**2

          mass(i) = mstar
          xx(i) = xstar
          yy(i) = ystar
          zz(i) = zstar
          vx(i) = ustar
          vy(i) = vstar
          vz(i) = wstar
40    continue
      pe = g*pe*mstar**2
      e_tidal = 0.5*alpha1*sumx + 0.5*alpha3*sumz
      ke = ke*0.5d0
      xmax = rc*rlag
      ymax = rc*ymax
      zmax = rc*zmax

      write(0,*) 'aking: radii (user units):', xmax, ymax, zmax
      write(0,*) 'aking: "Jacobi radius" (from alpha1 ',
     $        'with phi ~ -1/r; user units):',
     $        (-g*mtot/alpha1)**(0.3333333333)


      if (n.gt.1) then
          rvir = -g*mtot**2/(2.d0*pe)
          rvir_tidal = -g*mtot**2/(2.d0*(pe+e_tidal))
          write(0,*) 'aking: virial radius of N-body system ',
     $            '(user units):', rvir
          write(0,*) 'aking: ....same, but with tidal potential ',
     $            'included:', rvir_tidal

      endif

c     Derived quantities (user units) returned to calling program:

      potential = pe
      kinetic = ke
      tidal_energy = e_tidal

      return
      end

c

      subroutine difeq(k,k1,k2,jsf,is1,isf,indexv,ne,s,nsi,nsj,y,nyj,nyk
     &        )
      implicit double precision (a-h,o-z)
      parameter(m=51)
      common x(m),h,mm,n,c2,anorm
      common /params/ w0,alpha1,alpha3,rho(m),rhodot(m),rlag,
     &        yking(2,m),den,rking
      dimension y(nyj,nyk),s(nsi,nsj),indexv(nyj)

      g2(i) = -2.25d0*yking(2,i)**2*(rhodot(i)*(y(1,i) + (2.d0/9.d0)*
     &        exp(y(5,i))*yking(1,i)) - y(2,i)*rho(i))/yking(1,i)
      g4(i) = 0.25d0*yking(2,i)**2*(6.d0*y(3,i)/yking(1,i)-
     &        9.d0*rhodot(i)*(y(3,i) + (2.d0/3.d0)
     &        *exp(y(5,i))*yking(1,i))
     &        + 9.d0*y(4,i)*rho(i))/yking(1,i)

      if(k.eq.k1) then
          do i = 3,5
              do j = 6,10
                  s(i,j) = 0.d0
              enddo
          enddo
          eps = -exp(y(5,1))
          b0 = 0.1d0*eps*rhodot(1)
          s(3,5+1) = 1.d0
          s(3,5+5) = -b0*yking(1,1)**2
          s(3,jsf) = y(1,1) - b0*yking(1,1)**2
          s(4,5+2) = 1.d0
          s(4,5+5) = -2.d0*b0*yking(1,1)*yking(2,1)
          s(4,jsf) = y(2,1) - 2.d0*b0*yking(1,1)*yking(2,1)
          s(5,5+3) = yking(2,1)
          s(5,5+4) = -yking(1,1)
          s(5,jsf) = y(3,1)*yking(2,1) - yking(1,1)*y(4,1)
      else if(k.gt.k2) then
          do i = 1,2
              do j = 6,10
                  s(i,j) = 0.d0
              enddo
          enddo
          s(1,5+3) = 1.5d0*yking(2,m)
          s(1,5+4) = yking(1,m)
          s(1,jsf) = yking(1,m)*y(4,m) + 1.5d0*y(3,m)*yking(2,m)
c         now find radius where acceleration vanishes
          r = sqrt(yking(1,m))
          s0 = 1.5d0*(1.d0+alpha3/alpha1)
          s2 = -0.5d0*alpha3/alpha1 + 1.d0
          iter = 0
          eps = -exp(y(5,m))
          wc1 = -2.d0*yking(1,m)**1.5d0/yking(2,m)
          wc2 = -wc1/sqrt(yking(1,m))
          w0c1 = wc1*y(2,m)
          w0c2 = y(1,m) - w0c1/sqrt(yking(1,m))
          w2c1 = yking(1,m)**1.5d0*y(3,m)
10        continue
          iter = iter + 1
          if (iter.gt.20) then
              write(0,*) 'aking: too many iterations finding r'
              write(0,*) (y(i,m),i=1,5)
              stop
          endif
          f = -wc1/r**2 +s0*(-w0c1/r**2)
     &            -s2*3.d0*w2c1/r**4 - 2.d0*eps*r
          fdash = 2.d0*wc1/r**3 + 2.d0*s0*w0c1
     &            /r**3 +12.d0*s2*w2c1/r**5 -
     &            2.d0*eps
          rnew = r - f/fdash
          if (abs((r-rnew)/rnew).gt.1.d-4) then
              r = rnew
              go to 10
          endif
          r = rnew
          rlag = r
          temp = 1.d0 - sqrt(yking(1,m))/r
          s(2,5+1) = s0
          s(2,5+2) = s0*2.d0*(yking(1,m)/yking(2,m))*temp
          s(2,5+3) = s2*yking(1,m)**1.5d0/r**3
          s(2,5+5) = exp(y(5,m))*r**2
          s(2,jsf) = 2.d0*yking(1,m)*temp/yking(2,m) +
     &            s0*(y(1,m) + 2.d0*yking(1,m)*y(2,m)*temp/yking(2,m))
     &            + s2*yking(1,m)**1.5d0*y(3,m)/r**3
     &            - eps*r**2
      else
          do i = 1,5
              do j = 1,10
                  s(i,j)=0.d0
              enddo
          enddo
          halfh = 0.5d0*(x(k)-x(k-1))
          s(1,1) = -1.d0
          s(1,2) = -halfh
          s(1,5+1)=1.d0
          s(1,5+2)=-halfh
          s(1,jsf)=y(1,k)-y(1,k-1)-halfh*(y(2,k)+y(2,k-1))
          s(2,1) = -halfh*(-2.25d0*(yking(2,k-1)**2/yking(1,k-1))*
     &            rhodot(k-1))
          s(2,2) = -1.d0 - halfh*(-2.25d0*(yking(2,k-1)**2/
     &            yking(1,k-1))*
     &            (-rho(k-1)))
          s(2,5) = -halfh*(-2.25d0*(yking(2,k-1)**2/yking(1,k-1))*
     &            rhodot(k-1)*
     &            (2.d0/9.d0)*exp(y(5,k-1))*yking(1,k-1))
          s(2,5+1) = -halfh*(-2.25d0*(yking(2,k)**2/
     &            yking(1,k))*rhodot(k))
          s(2,5+2) = 1.d0 - halfh*(-2.25d0*(yking(2,k)**2/yking(1,k))*
     &            (-rho(k)))
          s(2,5+5) = -halfh*(-2.25d0*(yking(2,k)**2/
     &            yking(1,k))*rhodot(k)*
     &            (2.d0/9.d0)*exp(y(5,k))*yking(1,k))
          s(2,jsf) = y(2,k)-y(2,k-1)-halfh*(g2(k-1)+g2(k))
          s(3,3) = -1.d0
          s(3,4) = -halfh
          s(3,5+3)=1.d0
          s(3,5+4)=-halfh
          s(3,jsf)=y(3,k)-y(3,k-1)-halfh*(y(4,k)+y(4,k-1))
          s(4,3) = -halfh*(0.25d0*(yking(2,k-1)**2/
     &            yking(1,k-1))*(6.d0/
     &            yking(1,k-1) 
     &            -9.d0*rhodot(k-1)))
          s(4,4) = -1.d0 - halfh*(0.25d0*(yking(2,k-1)**2/
     &            yking(1,k-1))*
     &            9.d0*
     &            rho(k-1))
          s(4,5) = -halfh*(0.25d0*(yking(2,k-1)**2/
     &            yking(1,k-1))*(-9.d0)*
     &            rhodot(k-1)*(2.d0/3.d0)*exp(y(5,k-1))*yking(1,k-1))
          s(4,5+3) = -halfh*(0.25d0*(yking(2,k)**2/
     &            yking(1,k))*(6.d0/
     &            yking(1,k) 
     &            -9.d0*rhodot(k)))
          s(4,5+4) = 1.d0 - halfh*(0.25d0*(yking(2,k)**2/
     &            yking(1,k))*9.d0*
     &            rho(k))
          s(4,5+5) = -halfh*(0.25d0*(yking(2,k)**2/
     &            yking(1,k))*(-9.d0)*
     &            rhodot(k)*(2.d0/3.d0)*exp(y(5,k))*yking(1,k))
          s(4,jsf) = y(4,k)-y(4,k-1)-halfh*(g4(k-1)+g4(k))
          s(5,5) = -1.d0
          s(5,5+5) = 1.d0
          s(5,jsf) = -y(5,k-1) + y(5,k)
      endif

      return
      end

c

      subroutine solvde(itmax,conv,slowc,scalv,indexv,ne,nb,m,
     &        y,nyj,nyk,c,nci,ncj,nck,s,nsi,nsj,debug)
      implicit double precision (a-h,o-z)
      integer debug
      parameter (nmax=10)
      dimension y(nyj,nyk),c(nci,ncj,nck),s(nsi,nsj),scalv(nyj),indexv(n
     &        yj)
      dimension ermax(nmax),kmax(nmax)

      k1=1
      k2=m
      nvars=ne*m
      j1=1
      j2=nb
      j3=nb+1
      j4=ne
      j5=j4+j1
      j6=j4+j2
      j7=j4+j3
      j8=j4+j4
      j9=j8+j1
      ic1=1
      ic2=ne-nb
      ic3=ic2+1
      ic4=ne
      jc1=1
      jcf=ic3
      do 16 it=1,itmax
          k=k1
          call difeq(k,k1,k2,j9,ic3,ic4,indexv,ne,s,nsi,nsj,y,nyj,nyk)
          call pinvs(ic3,ic4,j5,j9,jc1,k1,c,nci,ncj,nck,s,nsi,nsj)
          do 11 k=k1+1,k2
              kp=k-1
              call difeq(k,k1,k2,j9,ic1,ic4,indexv,ne,s,nsi,nsj,y,nyj,
     &                nyk)
              call red(ic1,ic4,j1,j2,j3,j4,j9,ic3,jc1,jcf,kp,
     &                c,nci,ncj,nck,s,nsi,nsj)
              call pinvs(ic1,ic4,j3,j9,jc1,k,c,nci,ncj,nck,s,nsi,nsj)
11        continue
          k=k2+1
          call difeq(k,k1,k2,j9,ic1,ic2,indexv,ne,s,nsi,nsj,y,nyj,nyk)
          call red(ic1,ic2,j5,j6,j7,j8,j9,ic3,jc1,jcf,k2,
     &            c,nci,ncj,nck,s,nsi,nsj)
          call pinvs(ic1,ic2,j7,j9,jcf,k2+1,c,nci,ncj,nck,s,nsi,nsj)
          call bksub(ne,nb,jcf,k1,k2,c,nci,ncj,nck)
          err=0.
          do 13 j=1,ne
              jv=indexv(j)
              ermax(j)=0.
              errj=0.
              kmax(j)=0
              vmax=0.
              do 12 k=k1,k2
                  vz=abs(c(j,1,k))
                  if(vz.gt.vmax) then
                      vmax=vz
                      km=k
                  endif
                  errj=errj+vz
12            continue
              err=err+errj/scalv(jv)
              ermax(j)=c(j,1,km)/scalv(jv)
              kmax(j)=km
13        continue
          err=err/nvars
          fac=slowc/max(slowc,err)
          do 15 jv=1,ne
              j=indexv(jv)
              do 14 k=k1,k2
                  y(j,k)=y(j,k)-fac*c(jv,1,k)
14            continue
15        continue
          if (debug .lt. 0)
     &            write(0,100) it,err,fac,(kmax(j),ermax(j),j=1,ne)
          if (err.lt.conv) return
16    continue
      write(0,*) 'aking: itmax exceeded'
      stop
100   format(1x,i4,2f12.6,(/5x,i5,f12.6))
      end


      subroutine bksub(ne,nb,jf,k1,k2,c,nci,ncj,nck)
      implicit double precision (a-h,o-z)
      dimension c(nci,ncj,nck)
      nbf=ne-nb
      do 13 k=k2,k1,-1
          kp=k+1
          do 12 j=1,nbf
              xx=c(j,jf,kp)
              do 11 i=1,ne
                  c(i,jf,k)=c(i,jf,k)-c(i,j,k)*xx
11            continue
12        continue
13    continue
      do 16 k=k1,k2
          kp=k+1
          do 14 i=1,nb
              c(i,1,k)=c(i+nbf,jf,k)
14        continue
          do 15 i=1,nbf
              c(i+nb,1,k)=c(i,jf,kp)
15        continue
16    continue

      return
      end

c

      subroutine pinvs(ie1,ie2,je1,jsf,jc1,k,c,nci,ncj,nck,s,nsi,nsj)
      implicit double precision (a-h,o-z)
      parameter (zero=0.,one=1.,nmax=10)
      dimension c(nci,ncj,nck),s(nsi,nsj),pscl(nmax),indxr(nmax)

      je2=je1+ie2-ie1
      js1=je2+1
      do 12 i=ie1,ie2
          big=zero
          do 11 j=je1,je2
              if(abs(s(i,j)).gt.big) big=abs(s(i,j))
11        continue
          if(big.eq.zero) then
              write(0,*) 'aking: singular matrix, row all 0'
              stop
          endif
          pscl(i)=one/big
          indxr(i)=0
12    continue
      do 18 id=ie1,ie2
          piv=zero
          do 14 i=ie1,ie2
              if(indxr(i).eq.0) then
                  big=zero
                  do 13 j=je1,je2
                      if(abs(s(i,j)).gt.big) then
                          jp=j
                          big=abs(s(i,j))
                      endif
13                continue
                  if(big*pscl(i).gt.piv) then
                      ipiv=i
                      jpiv=jp
                      piv=big*pscl(i)
                  endif
              endif
14        continue
          if(s(ipiv,jpiv).eq.zero) then
              write(0,*) 'aking: singular matrix'
              stop
          endif
          indxr(ipiv)=jpiv
          pivinv=one/s(ipiv,jpiv)
          do 15 j=je1,jsf
              s(ipiv,j)=s(ipiv,j)*pivinv
15        continue
          s(ipiv,jpiv)=one
          do 17 i=ie1,ie2
              if(indxr(i).ne.jpiv) then
                  if(s(i,jpiv).ne.zero) then
                      dum=s(i,jpiv)
                      do 16 j=je1,jsf
                          s(i,j)=s(i,j)-dum*s(ipiv,j)
16                    continue
                      s(i,jpiv)=zero
                  endif
              endif
17        continue
18    continue
      jcoff=jc1-js1
      icoff=ie1-je1
      do 21 i=ie1,ie2
          irow=indxr(i)+icoff
          do 19 j=js1,jsf
              c(irow,j+jcoff,k)=s(i,j)
19        continue
21    continue

      return
      end


      subroutine red(iz1,iz2,jz1,jz2,jm1,jm2,jmf,ic1,jc1,jcf,kc,
     &        c,nci,ncj,nck,s,nsi,nsj)
      implicit double precision (a-h,o-z)
      dimension c(nci,ncj,nck),s(nsi,nsj)

      loff=jc1-jm1
      ic=ic1
      do 14 j=jz1,jz2
          do 12 l=jm1,jm2
              vx=c(ic,l+loff,kc)
              do 11 i=iz1,iz2
                  s(i,l)=s(i,l)-s(i,j)*vx
11            continue
12        continue
          vx=c(ic,jcf,kc)
          do 13 i=iz1,iz2
              s(i,jmf)=s(i,jmf)-s(i,j)*vx
13        continue
          ic=ic+1
14    continue

      return
      end


      double precision function dch_erf(x)
      implicit double precision (a-h,o-z)

      half = 0.5d0
      if(x.lt.0.)then
          dch_erf=-gammp(half,x**2)
      else
          dch_erf=gammp(half,x**2)
      endif

      return
      end


      double precision function gammp(a,x)
      implicit double precision (a-h,o-z)

      if(x.lt.0..or.a.le.0.) stop
      if(x.lt.a+1.)then
          call gser(gammp,a,x,gln)
      else
          call gcf(gammcf,a,x,gln)
          gammp=1.-gammcf
      endif

      return
      end


      subroutine gser(gamser,a,x,gln)
      implicit double precision (a-h,o-z)
      parameter (itmax=100,eps=3.e-7)

      gln=gammln(a)
      if(x.le.0.)then
          if(x.lt.0.) stop
          gamser=0.
          return
      endif
      ap=a
      sum=1./a
      del=sum
      do 11 n=1,itmax
          ap=ap+1.
          del=del*x/ap
          sum=sum+del
          if(abs(del).lt.abs(sum)*eps)go to 1
11    continue
      write(0,*) 'aking: a too large, itmax too small'
      stop
1     gamser=sum*exp(-x+a*log(x)-gln)

      return
      end


      double precision function gammln(xx)
      implicit double precision (a-h,o-z)
      real*8 cof(6),stp,half,one,fpf,x,tmp,ser
      data cof,stp/76.18009173d0,-86.50532033d0,24.01409822d0,
     &        -1.231739516d0,.120858003d-2,-.536382d-5,2.50662827465d0/
      data half,one,fpf/0.5d0,1.0d0,5.5d0/

      x=xx-one
      tmp=x+fpf
      tmp=(x+half)*log(tmp)-tmp
      ser=one
      do 11 j=1,6
          x=x+one
          ser=ser+cof(j)/x
11    continue
      gammln=tmp+log(stp*ser)

      return
      end


      subroutine gcf(gammcf,a,x,gln)
      implicit double precision (a-h,o-z)
      parameter (itmax=100,eps=3.e-7)

      gln=gammln(a)
      gold=0.
      a0=1.
      a1=x
      b0=0.
      b1=1.
      fac=1.
      do 11 n=1,itmax
          an=float(n)
          ana=an-a
          a0=(a1+a0*ana)*fac
          b0=(b1+b0*ana)*fac
          anf=an*fac
          a1=x*a0+anf*a1
          b1=x*b0+anf*b1
          if(a1.ne.0.)then
              fac=1./a1
              g=b1*fac
              if(abs((g-gold)/g).lt.eps)go to 1
              gold=g
          endif
11    continue
      write(0,*) 'aking: a too large, itmax too small'
      stop
1     gammcf=exp(-x+a*log(x)-gln)*g

      return
      end


      double precision function notsogoodran2(idum)

c     Notes from Steve, 7/16/98:
c
c     This is the RAN2 random number generator from Numerical Recipes
c     (first FORTRAN edition, ~1986 or so).  It has a number of limitations,
c     and seems to fail when too many calls are made to it..
c
c     This generator will fail (with j out of range) if idum is too big.
c     For the parameters below, the limit is idum < 150999.
c
c     (The mod function returns negative values for negative arguments
c     so, if ia*idum+ic <= 0 during the do-iteration below, j will go
c     out of range.  This requires that the initial idum satisfy
c
c		ia * (ic - idum) + ic > 0
c     or
c		idum < ic + ic/ia
c		     = ic + 110
c		     = 150999.)

      implicit none
      integer m, ia, ic, iff, j, iy, idum
      integer idum_save, idum_prev, count
      double precision rm
      parameter (m=714025, ia=1366, ic=150889, rm=1.4005112e-6)
      integer ir(97)

c     Note from Steve 7/15/98: the "save" here is crucially important!

      save iff, ir, iy, idum_save, idum_prev, count
      data iff /0/ count /0/

      idum_prev = idum_save
      idum_save = idum
      count = count + 1

      if(idum.lt.0.or.iff.eq.0)then
          iff=1
          idum=mod(ic-idum, m)
          do j=1,97
              idum=mod(ia*idum+ic, m)
              ir(j)=idum
          enddo
          idum=mod(ia*idum+ic, m)
          iy=idum
      endif
      j=1+(97*iy)/m
      if(j.gt.97.or.j.lt.1) then
          write(0,*)'aking: ran2:  j = ', j, '  count = ', count
          write(0,*)'              idum = ', idum,
     +		    '  ia*idum+ic = ', ia*idum+ic
          write(0,*)'              idum_prev = ', idum_prev,
     +		    '  ia*idum_prev+ic = ', ia*idum_prev+ic
          stop
      endif
      iy=ir(j)

      notsogoodran2=iy*rm

      idum=mod(ia*idum+ic, m)
      ir(j)=idum

c     write(0,*)count, idum

      return
      end


      double precision function betterran2(idum)

c     Fortran-ized version of the ran2 function from "Numerical Recipes
c     in C," 2nd edition.  Works much better than the older Fortran code,
c     and is also the basis of randinter() used in the rest of Starlab.


c     ***** An even better solution is to use a wrapper to allow     *****
c     ***** Fortran to use the C++ function randinter! (Steve, 8/99) *****


c     Implemented by Steve, 8/99.

      implicit none

      integer idum
      integer IM1, IM2, IMM1, IA1, IA2, IQ1, IQ2, IR1, IR2, NTAB, NDIV
      double precision AM, EPS, RNMX

      parameter (IM1 = 2147483563)
      parameter (IM2 = 2147483399)
      parameter (AM = (1.0/IM1))
      parameter (IMM1 = (IM1-1))
      parameter (IA1 = 40014)
      parameter (IA2 = 40692)
      parameter (IQ1 = 53668)
      parameter (IQ2 = 52774)
      parameter (IR1 = 12211)
      parameter (IR2 = 3791)
      parameter (NTAB = 32)
      parameter (NDIV = (1+IMM1/NTAB))
      parameter (EPS = 1.e-14)
      parameter (RNMX = (1.0-EPS))

      integer init, j, k, idum2, iy, iv(NTAB)

      save init, idum2, iy, iv
      data init /0/ idum2 /123456789/ iy /0/

c     Initialize if idum < 0.

      if (idum .le. 0 .or. init .eq. 0) then

c         write(0,*)'Initializing....'

          if (idum .lt. 0) idum = -idum
          if (idum .eq.0) idum = 1
          idum2 = idum

          do j = NTAB+8, 1, -1
              k = (idum)/IQ1
              idum = IA1*(idum-k*IQ1) - k*IR1
              if (idum .lt. 0) idum = idum + IM1
              if (j .le. NTAB) iv(j) = idum
          end do
          iy = iv(1)

          init = 1
      end if

c     write(0,*)'idum = ', idum

      k = (idum)/IQ1
      idum = IA1*(idum-k*IQ1) - k*IR1
      if (idum .lt. 0) idum = idum + IM1

c     write(0,*)'idum = ', idum

      k = idum2/IQ2
      idum2 = IA2*(idum2-k*IQ2)-k*IR2
      if (idum2 .lt. 0) idum2 = idum2 + IM2

c     write(0,*)'idum2 = ', idum2

      j = iy/NDIV + 1
      iy = iv(j) - idum2
      iv(j) = idum
      if (iy .lt. 1) iy = iy + IMM1

c     write(0,*)'iy = ', iy

      betterran2 = AM*iy
      if (betterran2 .gt. RNMX) betterran2 = RNMX

      write(0,*) betterran2

      return
      end


      subroutine odeint(ystart,nvar,x1,x2,eps,h1,hmin,nok,nbad,
     &        derivs,rkqc)
      implicit double precision(a-h,o-z)
      parameter (maxstp=10000,nmax=10,two=2.0,zero=0.0,tiny=1.e-30)
      common /path/ kmax,kount,dxsav,xp(200),yp(10,200)
      dimension ystart(nvar),yscal(nmax),y(nmax),dydx(nmax)
      external derivs

      x=x1
      h=sign(h1,x2-x1)
      nok=0
      nbad=0
      kount=0
      do 11 i=1,nvar
          y(i)=ystart(i)
11    continue
      xsav=x-dxsav*two
      do 16 nstp=1,maxstp
          call derivs(x,y,dydx)
          do 12 i=1,nvar
              yscal(i)=abs(y(i))+abs(h*dydx(i))+tiny
12        continue
          if(kmax.gt.0)then
              if(abs(x-xsav).gt.abs(dxsav)) then
                  if(kount.lt.kmax-1)then
                      kount=kount+1
                      xp(kount)=x
                      do 13 i=1,nvar
                          yp(i,kount)=y(i)
13                    continue
                      xsav=x
                  endif
              endif
          endif
          if((x+h-x2)*(x+h-x1).gt.zero) h=x2-x
          call rkqc(y,dydx,nvar,x,h,eps,yscal,hdid,hnext,derivs)
          if(hdid.eq.h)then
              nok=nok+1
          else
              nbad=nbad+1
          endif
          if((x-x2)*(x2-x1).ge.zero)then
              do 14 i=1,nvar
                  ystart(i)=y(i)
14            continue
              if(kmax.ne.0)then
                  kount=kount+1
                  xp(kount)=x
                  do 15 i=1,nvar
                      yp(i,kount)=y(i)
15                continue
              endif
              return
          endif
          if(abs(hnext).lt.hmin) then
              write(0,*) 'aking: stepsize smaller than minimum.'
              stop
          endif
          h=hnext
16    continue

      write(0,*) 'aking: too many steps.'
      stop
      end


      subroutine rkqc(y,dydx,n,x,htry,eps,yscal,hdid,hnext,derivs)
      implicit double precision (a-h,o-z)
      parameter (nmax=10,fcor=.0666666667,
     &        one=1.,safety=0.9,errcon=6.e-4)
      external derivs
      dimension y(n),dydx(n),yscal(n),ytemp(nmax),ysav(nmax),dysav(nmax)

      pgrow=-0.20
      pshrnk=-0.25
      xsav=x
      do 11 i=1,n
          ysav(i)=y(i)
          dysav(i)=dydx(i)
11    continue
      h=htry
1     hh=0.5*h
      call rk4(ysav,dysav,n,xsav,hh,ytemp,derivs)
      x=xsav+hh
      call derivs(x,ytemp,dydx)
      call rk4(ytemp,dydx,n,x,hh,y,derivs)
      x=xsav+h
      if(x.eq.xsav) then
          write(0,*) 'aking: stepsize not significant in rkqc.'
          stop
      endif
      call rk4(ysav,dysav,n,xsav,h,ytemp,derivs)
      errmax=0.
      do 12 i=1,n
          ytemp(i)=y(i)-ytemp(i)
          errmax=max(errmax,abs(ytemp(i)/yscal(i)))
12    continue
      errmax=errmax/eps
      if(errmax.gt.one) then
          h=safety*h*(errmax**pshrnk)
          goto 1
      else
          hdid=h
          if(errmax.gt.errcon)then
              hnext=safety*h*(errmax**pgrow)
          else
              hnext=4.*h
          endif
      endif
      do 13 i=1,n
          y(i)=y(i)+ytemp(i)*fcor
13    continue

      return
      end


      subroutine rk4(y,dydx,n,x,h,yout,derivs)
      implicit double precision (a-h,o-z)
      parameter (nmax=10)
      dimension y(n),dydx(n),yout(n),yt(nmax),dyt(nmax),dym(nmax)

      hh=h*0.5
      h6=h/6.
      xh=x+hh
      do 11 i=1,n
          yt(i)=y(i)+hh*dydx(i)
11    continue
      call derivs(xh,yt,dyt)
      do 12 i=1,n
          yt(i)=y(i)+hh*dyt(i)
12    continue
      call derivs(xh,yt,dym)
      do 13 i=1,n
          yt(i)=y(i)+h*dym(i)
          dym(i)=dyt(i)+dym(i)
13    continue
      call derivs(x+h,yt,dyt)
      do 14 i=1,n
          yout(i)=y(i)+h6*(dydx(i)+dyt(i)+2.*dym(i))
14    continue

      return
      end


      subroutine derivs (x,y,dydx)
      implicit double precision (a-h,o-z)
      parameter (nvar=2,m=51)
      common /params/ w0,alpha1,alpha3,rho(m),rhodot(m),rlag,yking(2,m),
     &        den,rking
      dimension y(nvar),dydx(nvar)

      pi = 4.d0*datan(1.d0)
      if (x.ge.0.d0) then
          rhox =-sqrt(x)*(x+1.5d0)+0.75*sqrt(pi)*exp(x)
     &                  *dch_erf(sqrt(x))
      else
          rhox = 0.d0
      endif
      dydx(1) = y(2)
      dydx(2) = 0.25d0*y(2)**2*(6.d0+9.d0*y(2)*rhox/den)/y(1)

      return
      end


      double precision function sigma(xstar,zstar,y)
      implicit double precision (a-h,o-z)
      parameter (ne=5,m=51)
      common /params/ w0,alpha1,alpha3,rho(m),rhodot(m),rlag,
     &        yking(2,m),den,rking
      common x(m),h,mm,n,c2,anorm
      dimension y(ne,m)

      densty(z) = -sqrt(z)*(z+1.5d0)+0.75*sqrt(pi)*exp(z)
     &                    *dch_erf(sqrt(z))

      eps = -exp(y(5,m))
      s0 = 1.5d0*(1.d0+alpha3/alpha1)
      wc1 = -2.d0*yking(1,m)**1.5d0/yking(2,m)
      wc2 = -wc1/sqrt(yking(1,m))
      w0c1 = wc1*y(2,m)
      w0c2 = y(1,m) - w0c1/sqrt(yking(1,m))
      w2c1 = yking(1,m)**1.5d0*y(3,m)
      pi = 4.d0*atan(1.d0)
      sum = 0.d0
      ystar = 0.d0
      coeff = 0.5d0
10    continue
      r2s2 = (alpha3/alpha1-0.5d0)*(zstar**2-0.5d0*(xstar**2+
     &        ystar**2))+ 0.75d0*(xstar**2-ystar**2)
      r2 = xstar**2 + ystar**2 + zstar**2
      if (r2.gt.0.d0) then
          s2 = r2s2/r2
      else
          s2 = 1.d0
      endif
      r = sqrt(r2)
      if (r.lt.rking) then
          if (r.lt.sqrt(yking(1,1))) then
              w1 = x(1) + y(1,1)*s0 + y(3,1)*s2 - eps*r**2*
     &                (2.d0/3.d0)*(s0/3.d0 + s2)
              w = w0 - (r2/yking(1,1))*(w0 - w1)
          else
              j = 1
20            continue
              j = j + 1
              if (r.gt.sqrt(yking(1,j))) goto 20
              wj1 = x(j-1) + y(1,j-1)*s0 + y(3,j-1)*s2 - eps*r**2*
     &                (2.d0/3.d0)*(s0/3.d0 + s2)
              wj = x(j) + y(1,j)*s0 + y(3,j)*s2 - eps*r**2*
     &                (2.d0/3.d0)*(s0/3.d0 + s2)
              w = wj1 + (r2-yking(1,j-1))*(wj-wj1)/
     &                (yking(1,j)-yking(1,j-1))
          endif
      else
          w = wc1/r + wc2
     &            +s0*(w0c1/r + w0c2) + s2*w2c1/r**3 - eps*r**2*
     &            (2.d0/3.d0)*(s0/3.d0 + s2)
      endif
      if (w.gt.0.d0) then
          rhost = densty(w)/den
          sum = sum + coeff*rhost
          if (coeff.lt.1.d0) coeff=1.d0
          ystar = ystar + 0.1
          goto 10
      else
          sigma = sum
          return
      endif

      end
